{
  "version": 3,
  "file": "index.modern.js",
  "sources": [
    "../src/provider.ts",
    "../src/lib.ts",
    "../src/routes.ts"
  ],
  "sourcesContent": [
    "import { JungleBusClient } from \"@gorillapool/js-junglebus\";\n// import * as Client from \"bitcoin-core\";\nimport fetch from \"cross-fetch\";\nimport createError from \"http-errors\";\nimport { Redis } from \"ioredis\";\n\nlet redis: Redis;\nif (process.env.REDIS_HOST) {\n  const host = process.env.REDIS_HOST;\n  const port = process.env.REDIS_PORT\n    ? parseInt(process.env.REDIS_PORT, 10)\n    : 6379;\n  console.log(\"Connecting to redis:\", host, port);\n  redis = new Redis(port, host);\n}\n\nexport interface ITxProvider {\n  network: string;\n  getRawTx: (string) => Promise<Buffer>;\n  getBlockchainInfo: () => Promise<{ height: number; hash: string }>;\n  getBlockByHeight: (number) => Promise<{ height: number; hash: string }>;\n  getBlockByHash: (string) => Promise<{ height: number; hash: string }>;\n}\n\n// export class RpcProvider implements ITxProvider {\n//   private client: Client;\n\n//   constructor(\n//     public network: string,\n//     host: string,\n//     port: string,\n//     username: string,\n//     password: string\n//   ) {\n//     this.client = new Client({\n//       host,\n//       port,\n//       username,\n//       password,\n//     });\n//   }\n\n//   async getRawTx(txid: string): Promise<Buffer> {\n//     let rawtx = await redis?.getBuffer(`rawtx:${txid}`);\n//     if (!rawtx) {\n//       rawtx = await this.client.getTransactionByHash(txid, {\n//         extension: \"bin\",\n//       });\n//       if (!rawtx) {\n//         throw new createError.NotFound();\n//       }\n//       redis?.set(`rawtx:${txid}`, rawtx);\n//     }\n//     return rawtx;\n//   }\n\n//   async getBlockchainInfo(): Promise<{ height: number; hash: string }> {\n//     const info = await this.client.getBlockchainInfo();\n//     return {\n//       height: info.blocks,\n//       hash: info.bestblockhash,\n//     };\n//   }\n\n//   async getBlockByHeight(\n//     height: number\n//   ): Promise<{ height: number; hash: string }> {\n//     const hash = await this.client.getBlockHash(height);\n//     return { height, hash };\n//   }\n\n//   async getBlockByHash(\n//     hash: string\n//   ): Promise<{ height: number; hash: string }> {\n//     const info = await this.client.getBlockHeader(hash);\n//     return {\n//       height: info.height,\n//       hash,\n//     };\n//   }\n// }\n\nexport class JungleBusProvider implements ITxProvider {\n  public network = \"bsv\";\n\n  async getRawTx(txid: string): Promise<Buffer> {\n    let rawtx = await redis?.getBuffer(`rawtx:${txid}`);\n    if (!rawtx) {\n      const jb = new JungleBusClient(\"https://junglebus.gorillapool.io\");\n      const txnData = await jb.GetTransaction(txid);\n      rawtx = Buffer.from(txnData!.transaction, \"base64\");\n      redis?.set(`rawtx:${txid}`, rawtx);\n    }\n    return rawtx;\n  }\n\n  async getBlockchainInfo(): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      \"https://api.whatsonchain.com/v1/bsv/main/block/headers\"\n    );\n    if (!resp.ok) {\n      throw createError(resp.status, resp.statusText);\n    }\n    const info = await resp.json();\n    return {\n      height: info[0].height,\n      hash: info[0].hash,\n    };\n  }\n\n  async getBlockByHeight(\n    height: number\n  ): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      `https://api.whatsonchain.com/v1/bsv/main/block/height/${height}`\n    );\n    const info = await resp.json();\n    return { height, hash: info.hash };\n  }\n\n  async getBlockByHash(\n    hash: string\n  ): Promise<{ height: number; hash: string }> {\n    const resp = await fetch(\n      `https://api.whatsonchain.com/v1/bsv/main/block/hash/${hash}`\n    );\n    const info = await resp.json();\n\n    return {\n      height: info.height,\n      hash,\n    };\n  }\n}\n\n// export class BtcProvider implements ITxProvider {\n//   public network = \"btc\";\n\n//   async getRawTx(txid: string): Promise<Buffer> {\n//     let rawtx = await redis?.getBuffer(`rawtx:${txid}`);\n//     if (!rawtx) {\n//       // TODO: Make this configuration based\n//       const resp = await fetch(\n//         `https://ordfs.gorillapool.io/v1/btc/tx/${txid}`\n//       );\n//       if (!resp.ok) {\n//         throw createError(resp.status, resp.statusText);\n//       }\n//       rawtx = Buffer.from(await resp.arrayBuffer());\n//       redis?.set(`rawtx:${txid}`, rawtx);\n//     }\n//     return rawtx;\n//   }\n\n//   async getBlockchainInfo(): Promise<{ height: number; hash: string }> {\n//     // TODO: Make this configuration based\n//     const resp = await fetch(\n//       \"https://ordfs.gorillapool.io/v1/btc/block/latest\"\n//     );\n//     if (!resp.ok) {\n//       throw createError(resp.status, resp.statusText);\n//     }\n\n//     return resp.json();\n//   }\n\n//   async getBlockByHeight(\n//     height: number\n//   ): Promise<{ height: number; hash: string }> {\n//     const resp = await fetch(\n//       `https://ordfs.gorillapool.io/v1/btc/block/height/${height}`\n//     );\n//     const info = await resp.json();\n//     return { height, hash: info.hash };\n//   }\n\n//   async getBlockByHash(\n//     hash: string\n//   ): Promise<{ height: number; hash: string }> {\n//     const resp = await fetch(\n//       `https://ordfs.gorillapool.io/v1/btc/block/hash/${hash}`\n//     );\n//     const info = await resp.json();\n\n//     return {\n//       height: info.height,\n//       hash,\n//     };\n//   }\n// }\n",
    "import { OpCode, Script, Tx } from \"@ts-bitcoin/core\";\n// import { Transaction } from \"bitcore-lib\";\nimport * as dns from \"dns/promises\";\nimport createError from \"http-errors\";\nimport fetch from \"cross-fetch\";\nimport {\n  // BtcProvider,\n  ITxProvider,\n  JungleBusProvider,\n  // RpcProvider,\n} from \"./provider\";\n\nconst B = Buffer.from(\"19HxigV4QyBv3tHpQVcUEQyq1pzZVdoAut\");\nconst ORD = Buffer.from(\"ord\");\n\n// let btcProvider: ITxProvider = new BtcProvider();\nlet bsvProvider: ITxProvider = new JungleBusProvider();\n\n// if (process.env.BITCOIN_HOST) {\n//   bsvProvider = new RpcProvider(\n//     \"bsv\",\n//     process.env.BITCOIN_HOST || \"\",\n//     process.env.BITCOIN_PORT || \"8332\",\n//     process.env.BITCOIN_USER || \"\",\n//     process.env.BITCOIN_PASS || \"\"\n//   );\n// }\n\n// if (process.env.BTC_HOST) {\n//   btcProvider = new RpcProvider(\n//     \"btc\",\n//     process.env.BTC_HOST || \"\",\n//     process.env.BTC_PORT || \"8332\",\n//     process.env.BTC_USER || \"\",\n//     process.env.BTC_PASS || \"\"\n//   );\n// }\n\nexport async function getLatestBlock(\n  network: string\n): Promise<{ height: number; hash: string }> {\n  switch (network) {\n    // case \"btc\":\n    //   return btcProvider.getBlockchainInfo();\n    case \"bsv\":\n      return bsvProvider.getBlockchainInfo();\n    default:\n      throw new createError.NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function getBlockByHeight(\n  network: string,\n  height: number\n): Promise<{ height: number; hash: string }> {\n  switch (network) {\n    // case \"btc\":\n    //   return btcProvider.getBlockByHeight(height);\n    case \"bsv\":\n      return bsvProvider.getBlockByHeight(height);\n    default:\n      throw new createError.NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function getBlockByHash(\n  network: string,\n  hash: string\n): Promise<{ height: number; hash: string }> {\n  switch (network) {\n    // case \"btc\":\n    //   return btcProvider.getBlockByHash(hash);\n    case \"bsv\":\n      return bsvProvider.getBlockByHash(hash);\n    default:\n      throw new createError.NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function getRawTx(\n  network: string,\n  txid: string\n): Promise<Buffer | undefined> {\n  switch (network) {\n    // case \"btc\":\n    //   return btcProvider.getRawTx(txid);\n    case \"bsv\":\n      return bsvProvider.getRawTx(txid);\n    default:\n      throw new createError.NotFound(\"Network Not Found\");\n  }\n}\n\nexport async function loadPointerFromDNS(hostname: string): Promise<string> {\n  const lookupDomain = `_ordfs.${hostname}`;\n  const TXTs = await dns.resolveTxt(lookupDomain);\n  const prefix = \"ordfs=\";\n  let pointer = \"\";\n  console.log(\"Lookup Up:\", lookupDomain);\n  outer: for (const TXT of TXTs) {\n    for (const elem of TXT) {\n      if (!elem.startsWith(prefix)) continue;\n      console.log(\"Elem:\", elem);\n      pointer = elem.slice(prefix.length);\n      console.log(\"Origin:\", pointer);\n      break outer;\n    }\n\n    if (!pointer) {\n      throw new createError.NotFound();\n    }\n  }\n  return pointer;\n}\n\nexport async function loadInscription(pointer: string, metadata = false): Promise<File> {\n  console.log(\"loadInscription\", pointer);\n  let file: File | undefined;\n  if (pointer.match(/^[0-9a-fA-F]{64}_\\d*$/)) {\n    const [txid, vout] = pointer.split(\"_\");\n    console.log(\"BSV:\", txid, vout);\n    const rawtx = await bsvProvider.getRawTx(txid);\n    if (!rawtx) throw new Error(\"No raw tx found\");\n    const tx = Tx.fromBuffer(rawtx);\n    const v = parseInt(vout, 10);\n    const script = tx.txOuts[v].script;\n    if (!script) throw new createError.NotFound();\n    file = parseScript(script);\n    if (file && metadata) {\n      try {\n        const url =`https://ordinals.gorillapool.io/api/inscriptions/outpoint/${pointer}`;\n        const resp = await fetch(url);\n        const data = await resp.json();\n        const { hash } = await bsvProvider.getBlockByHeight(data!.height);\n        const meta: Meta = {\n          height: data.height,\n          MAP: data.MAP,\n          hash,\n          txid,\n          v,\n        };\n        file.meta = meta;\n      } catch {};\n    }\n  // } else if (pointer.match(/^[0-9a-fA-F]{64}i\\d+$/) && btcProvider) {\n  //   const [txid, vin] = pointer.split(\"i\");\n  //   console.log(\"BTC\", txid, vin);\n  //   const rawtx = await btcProvider.getRawTx(txid);\n  //   if (!rawtx) throw new Error(\"No raw tx found\");\n  //   const tx = new Transaction(rawtx);\n  //   const script = Script.fromBuffer(tx.inputs[parseInt(vin, 10)].witnesses[1]);\n  //   if (!script) throw new createError.NotFound();\n  //   file = parseScript(script);\n  } else throw new Error(\"Invalid Pointer\");\n\n  if (!file) throw new createError.NotFound();\n  return file;\n}\n\nexport interface Meta {\n  height?: number;\n  hash?: string;\n  txid: string;\n  v: number;\n  MAP?: {[key:string]:any}\n}\n\nexport interface File {\n  type: string;\n  data: Buffer;\n  meta?: Meta;\n}\n\nexport interface OrdFS {\n  [filename: string]: string;\n}\n\nexport function parseScript(script: Script): File | undefined {\n  let opFalse = 0;\n  let opIf = 0;\n  let opORD = 0;\n\n  let type = \"application/octet-stream\";\n  let data = Buffer.alloc(0);\n  for (const [i, chunk] of script.chunks.entries()) {\n    if (chunk.buf?.equals(B) && script.chunks.length > i + 2) {\n      data = script.chunks[i + 1].buf!;\n      type = script.chunks[i + 2].buf!.toString();\n      return { data, type };\n    }\n    if (chunk.opCodeNum === OpCode.OP_FALSE) {\n      opFalse = i;\n    }\n    if (chunk.opCodeNum === OpCode.OP_IF) {\n      opIf = i;\n    }\n    if (chunk.buf?.equals(ORD) && opFalse === i - 2 && opIf === i - 1) {\n      opORD = i;\n      break;\n    }\n  }\n\n  for (let i = opORD + 1; i < script.chunks.length; i++) {\n    switch (script.chunks[i].opCodeNum) {\n      case OpCode.OP_FALSE:\n        while (\n          script.chunks[i + 1]?.opCodeNum >= 1 &&\n          script.chunks[i + 1]?.opCodeNum <= OpCode.OP_PUSHDATA4\n        ) {\n          data = Buffer.concat([data, script.chunks[i + 1].buf!]);\n          i++;\n        }\n        break;\n      case 1:\n        // treat 1 like OP_1 (BTC convention)\n        // console.log(script.chunks[i].toString('hex'))\n        if (script.chunks[i].buf![0] != 1) return;\n      case OpCode.OP_TRUE:\n        type = script.chunks[i + 1]!.buf!.toString(\"utf8\");\n        // console.log(\"Type:\", type)\n        i++;\n        break;\n      case OpCode.OP_ENDIF:\n        return { type, data };\n      default:\n        return;\n    }\n  }\n\n  return { type, data };\n}\n",
    "import * as express from \"express\";\nimport { Response } from \"express\";\nimport createError from \"http-errors\";\nimport {\n  File,\n  OrdFS,\n  getBlockByHash,\n  getBlockByHeight,\n  getLatestBlock,\n  getRawTx,\n  loadInscription,\n  loadPointerFromDNS,\n} from \"./lib\";\n\nfunction sendFile(file: File, res: Response, immutable = true) {\n  res.header(\"Content-Type\", file.type || \"\");\n  if (file.meta) {\n    res.header('ordfs-meta', JSON.stringify(file.meta))\n  }\n  if (immutable && !file.meta) {\n    res.header(\"Cache-Control\", \"public,immutable,max-age=31536000\");\n  }\n  res.status(200).send(file.data);\n}\n\nexport function RegisterRoutes(app: express.Express) {\n  app.get(\"/\", async (req, res) => {\n    let outpoint: string;\n    try {\n      outpoint = await loadPointerFromDNS(req.hostname);\n    } catch (e: any) {\n      // DNS pointer not found\n      res.render(\"pages/index\");\n      return;\n    }\n    try {\n      const file = await loadInscription(outpoint);\n      if (file.type === \"ord-fs/json\" && !req.query[\"raw\"]) {\n        req.res?.redirect(\"index.html\");\n        return;\n      }\n      sendFile(file, res, false);\n    } catch (err) {\n      // TODO: inscription not found\n      res.render(\"pages/404\");\n    }\n  });\n\n  app.get(\"/v1/:network/block/latest\", async (req, res, next) => {\n    try {\n      res.json(await getLatestBlock(req.params.network));\n    } catch (e) {\n      next(e);\n    }\n  });\n\n  app.get(\"/v1/:network/block/height/:height\", async (req, res, next) => {\n    try {\n      res.json(\n        await getBlockByHeight(\n          req.params.network,\n          parseInt(req.params.height, 10)\n        )\n      );\n    } catch (e) {\n      next(e);\n    }\n  });\n\n  app.get(\"/v1/:network/block/hash/:hash\", async (req, res, next) => {\n    try {\n      res.json(await getBlockByHash(req.params.network, req.params.hash));\n    } catch (e) {\n      next(e);\n    }\n  });\n\n  app.get(\"/v1/:network/tx/:txid\", async (req, res) => {\n    res.set(\"Content-type\", \"application/octet-stream\");\n    res.send(await getRawTx(req.params.network, req.params.txid));\n  });\n  app.get(\"/:filename\", getInscriptionOrDnsFile);\n  app.get(\"/content/:pointer\", getInscription);\n  app.get(\"/preview/:b64HtmlData\", previewHtmlFromB64Data);\n  app.get(\"/:pointer/:filename\", getOrdfsFile);\n  app.get(\"/content/:pointer/:filename\", getOrdfsFile);\n\n  async function previewHtmlFromB64Data(req, res, next) {\n    try {\n      const b64HtmlData = req.params.b64HtmlData;\n      const htmlData = Buffer.from(b64HtmlData, \"base64\").toString(\"utf8\");\n      res.render(\"pages/preview\", { htmlData });\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async function getInscriptionOrDnsFile(req, res, next) {\n    const filename = req.params.filename;\n    try {\n      let pointer: string;\n      let file: File;\n      let immutable = true;\n      try {\n        // check if its an ordfs directory\n        file = await loadInscription(filename, req.query.meta);\n        if (file.type === \"ord-fs/json\" && !req.query.raw) {\n          req.res?.redirect(`/${filename}/index.html`);\n          return;\n        }\n      } catch (e: any) {\n        console.error(\"Outpoint Error\", filename, e.message);\n        pointer = await loadPointerFromDNS(req.hostname);\n        const dirData = await loadInscription(pointer);\n        const dir = JSON.parse(dirData.data!.toString(\"utf8\"));\n        if (!dir[filename]) {\n          throw new createError.NotFound();\n        }\n        pointer = dir[filename].slice(6);\n        file = await loadInscription(pointer, req.query.meta);\n        immutable = false;\n      }\n      sendFile(file, res, immutable);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async function getInscription(req, res, next) {\n    const pointer = req.params.pointer;\n    try {\n      const file = await loadInscription(pointer, req.query.meta);\n      // check if its an ordfs directory\n      if (file.type === \"ord-fs/json\" && !req.query.raw) {\n        req.res?.redirect(`/${pointer}/index.html`);\n        return;\n      }\n      sendFile(file, res, true);\n    } catch (err) {\n      next(err);\n    }\n  }\n\n  async function getOrdfsFile(req, res, next) {\n    try {\n      let pointer = req.params.pointer;\n      const filename = req.params.filename;\n      const dirData = await loadInscription(pointer);\n      const dir: OrdFS = JSON.parse(dirData.data!.toString(\"utf8\"));\n      if (!dir[filename]) {\n        throw new createError.NotFound();\n      }\n      if (dir[filename].startsWith(\"ord://\")) {\n        pointer = dir[filename].slice(6);\n      } else {\n        pointer = dir[filename];\n      }\n      const file = await loadInscription(pointer, req.query.meta);\n      sendFile(file, res, true);\n    } catch (err) {\n      next(err);\n    }\n  }\n}\n"
  ],
  "names": [
    "redis",
    "process",
    "env",
    "REDIS_HOST",
    "host",
    "port",
    "REDIS_PORT",
    "parseInt",
    "console",
    "log",
    "Redis",
    "B",
    "Buffer",
    "from",
    "ORD",
    "bsvProvider",
    "constructor",
    "this",
    "network",
    "getRawTx",
    "txid",
    "_redis",
    "rawtx",
    "getBuffer",
    "_redis2",
    "jb",
    "JungleBusClient",
    "txnData",
    "GetTransaction",
    "transaction",
    "set",
    "getBlockchainInfo",
    "resp",
    "fetch",
    "ok",
    "createError",
    "status",
    "statusText",
    "info",
    "json",
    "height",
    "hash",
    "getBlockByHeight",
    "getBlockByHash",
    "async",
    "getLatestBlock",
    "NotFound",
    "loadPointerFromDNS",
    "hostname",
    "lookupDomain",
    "TXTs",
    "dns",
    "resolveTxt",
    "pointer",
    "outer",
    "TXT",
    "elem",
    "startsWith",
    "slice",
    "prefix",
    "loadInscription",
    "metadata",
    "file",
    "match",
    "Error",
    "vout",
    "split",
    "tx",
    "Tx",
    "fromBuffer",
    "v",
    "script",
    "txOuts",
    "parseScript",
    "url",
    "data",
    "meta",
    "MAP",
    "_unused",
    "opFalse",
    "opIf",
    "opORD",
    "type",
    "alloc",
    "i",
    "chunk",
    "chunks",
    "entries",
    "_chunk$buf",
    "_chunk$buf2",
    "buf",
    "equals",
    "length",
    "toString",
    "opCodeNum",
    "OpCode",
    "OP_FALSE",
    "OP_IF",
    "_script$chunks",
    "_script$chunks2",
    "OP_PUSHDATA4",
    "concat",
    "OP_TRUE",
    "OP_ENDIF",
    "sendFile",
    "res",
    "immutable",
    "header",
    "JSON",
    "stringify",
    "send",
    "RegisterRoutes",
    "app",
    "getOrdfsFile",
    "req",
    "next",
    "params",
    "filename",
    "dirData",
    "dir",
    "parse",
    "query",
    "err",
    "get",
    "outpoint",
    "e",
    "render",
    "_req$res",
    "redirect",
    "_req$res2",
    "raw",
    "error",
    "message",
    "_req$res3",
    "htmlData",
    "b64HtmlData"
  ],
  "mappings": "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"
}
